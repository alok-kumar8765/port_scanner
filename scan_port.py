# -*- coding: utf-8 -*-
"""Scan Port.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YySnBUN9SSeV6Dx6mHfUscsoZ6Zb7-8-
"""

# =============
# Port Scanner
# =============

import socket
import time

target = "scanme.nmap.org"
print(f"Starting Scan on : {target}")

start_time = time.time()

for port in range(20, 85):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	socket.setdefaulttimeout(0.5)

	result = s.connect_ex((target,port))

	if result == 0:
		print(f"found open port : {port}")

	s.close()

print(f"scan done : {time.time() - start_time:.2f}s")

"""# Task
Enhance the existing port scanner to prompt the user for the target host and port range, validate port inputs, identify services running on open ports, and improve the scan output format to clearly display the target, scanned ports, and identified services.

## Get User Input

### Subtask:
Modify the code to prompt the user for the target host (IP address or hostname) and the start and end ports for the scan. Implement basic input validation to ensure valid port numbers.

**Reasoning**:
I need to modify the existing port scanner code to allow the user to input the target host, starting port, and ending port, including input validation for the port numbers. This requires a new code block that incorporates these interactive elements and validation logic.
"""

import socket
import time

# Get target host from user
target = input('Enter the target host (e.g., scanme.nmap.org): ')

# Get start port with validation
while True:
    try:
        start_port = int(input('Enter the starting port (1-65535): '))
        if 1 <= start_port <= 65535:
            break
        else:
            print("Invalid port. Please enter a port between 1 and 65535.")
    except ValueError:
        print("Invalid input. Please enter an integer.")

# Get end port with validation
while True:
    try:
        end_port = int(input(f'Enter the ending port ({{start_port}}-65535): '))
        if start_port <= end_port <= 65535:
            break
        else:
            print(f"Invalid port. Please enter a port between {{start_port}} and 65535.")
    except ValueError:
        print("Invalid input. Please enter an integer.")

print(f"Starting Scan on : {target} from port {start_port} to {end_port}")

start_time = time.time()

for port in range(start_port, end_port + 1):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    socket.setdefaulttimeout(0.5)

    result = s.connect_ex((target, port))

    if result == 0:
        print(f"found open port : {port}")

    s.close()

print(f"scan done : {time.time() - start_time:.2f}s")

"""## Identify Port Services

### Subtask:
For each open port found, attempt to identify the service running on it. This can be done by using `socket.getservbyport` for well-known services or by trying to read a banner from the port for more specific information.

**Reasoning**:
The subtask requires identifying services on open ports. I will modify the existing code to include `socket.getservbyport` for well-known services and implement a basic banner grabbing technique for others within the `if result == 0:` block. This will involve updating the loop structure to try and identify the service and then print it along with the open port.
"""

import socket
import time

# Get target host from user
target = input('Enter the target host (e.g., scanme.nmap.org): ')

# Get start port with validation
while True:
    try:
        start_port = int(input('Enter the starting port (1-65535): '))
        if 1 <= start_port <= 65535:
            break
        else:
            print("Invalid port. Please enter a port between 1 and 65535.")
    except ValueError:
        print("Invalid input. Please enter an integer.")

# Get end port with validation
while True:
    try:
        end_port = int(input(f'Enter the ending port ({start_port}-65535): '))
        if start_port <= end_port <= 65535:
            break
        else:
            print(f"Invalid port. Please enter a port between {start_port} and 65535.")
    except ValueError:
        print("Invalid input. Please enter an integer.")

print(f"Starting Scan on : {target} from port {start_port} to {end_port}")

start_time = time.time()

open_ports_found = []

for port in range(start_port, end_port + 1):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    socket.setdefaulttimeout(0.5)

    result = s.connect_ex((target, port))

    if result == 0:
        service_name = 'Unknown'
        try:
            service_name = socket.getservbyport(port, 'tcp')
        except OSError:
            pass # Service not found in default list

        # If service is still 'Unknown' or not specific enough, try banner grabbing
        if service_name == 'Unknown' or service_name == '':
            try:
                # Create a new socket for banner grabbing with a shorter timeout
                banner_s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                banner_s.settimeout(0.2) # Shorter timeout for banner grabbing
                banner_s.connect((target, port))
                banner = banner_s.recv(1024).decode('utf-8', errors='ignore').strip()
                if banner:
                    service_name = banner[:50].replace('\n', ' ').replace('\r', ' ')
                banner_s.close()
            except (socket.timeout, ConnectionRefusedError, OSError):
                if service_name == 'Unknown' or service_name == '':
                    service_name = 'No banner/service info'
            finally:
                if 'banner_s' in locals() and banner_s.fileno() != -1: # Check if socket is still open
                    banner_s.close()

        print(f"found open port : {port} ({service_name})")
        open_ports_found.append(f"{port} ({service_name})")

    s.close()

print(f"scan done : {time.time() - start_time:.2f}s")
print(f"Scanned Target: {target}")
print(f"Scanned Port Range: {start_port}-{end_port}")
print(f"Open Ports and Services: {', '.join(open_ports_found) if open_ports_found else 'None'}")

"""## Improve Scan Output

### Subtask:
Format the output to clearly display the target, the ports scanned, and for each open port, its number and the identified service (if any).

**Reasoning**:
I need to modify the existing code to remove the `print` statement inside the scan loop and consolidate all output into a well-formatted summary block at the end, as per the instructions.
"""

import socket
import time

# Get target host from user
target = input('Enter the target host (e.g., scanme.nmap.org): ')

# Get start port with validation
while True:
    try:
        start_port = int(input('Enter the starting port (1-65535): '))
        if 1 <= start_port <= 65535:
            break
        else:
            print("Invalid port. Please enter a port between 1 and 65535.")
    except ValueError:
        print("Invalid input. Please enter an integer.")

# Get end port with validation
while True:
    try:
        end_port = int(input(f'Enter the ending port ({start_port}-65535): '))
        if start_port <= end_port <= 65535:
            break
        else:
            print(f"Invalid port. Please enter a port between {start_port} and 65535.")
    except ValueError:
        print("Invalid input. Please enter an integer.")

print(f"\n{'='*30}\nStarting Scan on: {target}\nScanning ports {start_port} to {end_port}\n{'='*30}")

start_time = time.time()

open_ports_found = []

for port in range(start_port, end_port + 1):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    socket.setdefaulttimeout(0.5)

    result = s.connect_ex((target, port))

    if result == 0:
        service_name = 'Unknown'
        try:
            service_name = socket.getservbyport(port, 'tcp')
        except OSError:
            pass # Service not found in default list

        # If service is still 'Unknown' or not specific enough, try banner grabbing
        if service_name == 'Unknown' or service_name == '':
            try:
                # Create a new socket for banner grabbing with a shorter timeout
                banner_s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                banner_s.settimeout(0.2) # Shorter timeout for banner grabbing
                banner_s.connect((target, port))
                banner = banner_s.recv(1024).decode('utf-8', errors='ignore').strip()
                if banner:
                    service_name = banner[:50].replace('\n', ' ').replace('\r', ' ')
                banner_s.close()
            except (socket.timeout, ConnectionRefusedError, OSError):
                if service_name == 'Unknown' or service_name == '':
                    service_name = 'No banner/service info'
            finally:
                if 'banner_s' in locals() and banner_s.fileno() != -1: # Check if socket is still open
                    banner_s.close()

        open_ports_found.append(f"  Port {port}: {service_name}")

    s.close()

end_time = time.time()
scan_duration = end_time - start_time

print(f"\n{'='*30}\nScan Results for {target}\n{'='*30}")
print(f"Target: {target}")
print(f"Scanned Port Range: {start_port}-{end_port}")
print(f"Scan Duration: {scan_duration:.2f}s")
print(f"Open Ports and Services:")
if open_ports_found:
    for item in open_ports_found:
        print(item)
else:
    print("  None")
print(f"{'='*30}\nScan Finished\n{'='*30}")

"""## Final Task

### Subtask:
Summarize the enhancements made to the port scanner and demonstrate its new functionality.

## Summary:

### Data Analysis Key Findings

*   **User Input and Validation**: The port scanner was enhanced to prompt the user for the target host and a custom port range (start and end ports). Robust input validation was implemented for port numbers, ensuring they fall within the valid range of 1-65535 and that the end port is not less than the start port. The validation also handles non-integer inputs gracefully.
*   **Service Identification**: The scanner now identifies services running on open ports using a two-pronged approach:
    *   It first attempts to use `socket.getservbyport` for well-known services.
    *   If that doesn't yield specific information, it performs banner grabbing by connecting to the open port and attempting to receive introductory data, which is then truncated to 50 characters and cleaned.
    *   In cases where no banner or service information is available, it explicitly labels the service as 'No banner/service info'. For example, port 22 was identified with an SSH banner, and port 80 showed 'No banner/service info'.
*   **Improved Output Format**: The scan output has been significantly improved for clarity.
    *   Intermediate print statements during the scan loop were removed to prevent noisy output.
    *   A consolidated summary is presented at the end of the scan, including the target host, the specific port range scanned (e.g., 20-90), and the total scan duration (e.g., 4.10s).
    *   Open ports and their identified services are listed clearly in a dedicated section (e.g., "Port 22: SSH-2.0-OpenSSH_6.6.1p1 Ubuntu-2ubuntu2.13").
    *   The output is framed with clear headers and footers for better readability.

### Insights or Next Steps

*   **Enhanced Information Gathering**: The scanner now provides valuable initial reconnaissance data by not only identifying open ports but also inferring the services running on them, which is crucial for security assessments.
*   **Further Service Detail**: The current banner grabbing captures up to 50 characters. For a more comprehensive understanding, consider implementing deeper banner parsing or using well-known service-specific probes to get more detailed version information for common protocols like HTTP, FTP, or SMTP.
"""

import socket
import concurrent.futures
import time

target = "scanme.nmap.org"

print(f"Starting Scan on: {target}")

start_time = time.time()

def scan_port(port):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(0.3)
        result = s.connect_ex((target, port))
        if result == 0:
            print(f"Open port: {port}")
        s.close()
    except:
        pass

with concurrent.futures.ThreadPoolExecutor(max_workers=100) as executor:
    executor.map(scan_port, range(1, 65536))

print(f"Scan done in {time.time() - start_time:.2f}s")